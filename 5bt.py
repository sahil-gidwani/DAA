first_queen_row = 4
first_queen_col = 0

def print_board(board):
    n = len(board)
    for i in range(n):
        for j in range(n):
            print(board[i][j], end=" ")
        print()

def is_safe(board, row, col):
    n = len(board)

    # Check left side of the current row
    for i in range(col):
        if board[row][i] == 1:
            return False

    # Check upper diagonal on the left side
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False

    # Check lower diagonal on the left side
    for i, j in zip(range(row, n), range(col, -1, -1)):
        if board[i][j] == 1:
            return False

    return True

def solve_n_queens(board, col):
    n = len(board)

    if col >= n:
        # All queens are placed, return True
        return True
    
    if col == first_queen_col:
        # First queen is placed, move to next column
        return solve_n_queens(board, col + 1)

    # Try placing the queen in each row of the current column
    for i in range(n):
        if i != first_queen_row and is_safe(board, i, col):
            # Place the queen
            board[i][col] = 1
            
            # Recur to place the rest of the queens
            if solve_n_queens(board, col + 1):
                return True

            # If placing the queen in board[i][col] doesn't lead to a solution, backtrack
            board[i][col] = 0

    return False

def main():
    n = 8  # Change 'n' to the desired board size
    board = [[0 for _ in range(n)] for _ in range(n)]

    # Place the first queen at
    board[first_queen_row][first_queen_col] = 1

    # Call the backtracking function to solve the rest of the board
    if solve_n_queens(board, 0):
        print("Solution exists:")
        print_board(board)
    else:
        print("No solution exists.")

if __name__ == "__main__":
    main()

# Time Complexity Analysis:
# The time complexity of this code is mainly determined by the `solve_n_queens` function, which utilizes backtracking to find the solutions. In the worst case, this backtracking algorithm explores all possible positions for the queens, resulting in an exponential time complexity of O(2^n), where 'n' is the size of the chessboard (number of rows and columns).
#
# Space Complexity Analysis:
# The space complexity is determined by the memory required for the chessboard, which is represented as a 2D array (`board`). The space complexity is O(n^2) since we have an 'n x n' chessboard. Additionally, there's some space required for function call stacks during the recursion, but it's generally smaller compared to the chessboard and can be considered negligible for large 'n'.

"""
The N-Queens problem is a classical combinatorial problem in chessboard-based puzzles. It asks for a placement of N chess queens on an N×N chessboard, in such a way that no two queens threaten each other. This means that no two queens can be in the same row, column, or diagonal. The goal is to find all distinct solutions to the problem, or sometimes just one solution.

Here are some key points about the N-Queens problem:

1. **Chessboard Setup:** The problem is typically presented on an N×N chessboard, where N is the number of queens to be placed.

2. **Valid Solutions:** In a valid solution, no two queens share the same row, column, or diagonal. This means that there is exactly one queen in each row and each column.

3. **Constraints:** The problem is constrained by the requirement that queens must not attack each other. A queen can attack any piece in its row, column, and along both diagonals.

4. **Search Algorithms:** Solving the N-Queens problem involves using various search and optimization algorithms. Backtracking algorithms, such as recursive depth-first search, are commonly employed to find solutions. Constraint programming and other heuristic-based methods can also be used.

5. **Solution Count:** For larger N values, the problem can have multiple solutions. Finding all distinct solutions is a common goal in solving the N-Queens problem.

6. **Symmetry and Rotations:** Solutions to the N-Queens problem often have rotational symmetry. This means that if a solution is found, several other solutions can be generated by rotating the board or mirroring it.

7. **Applications:** While the N-Queens problem is often considered a recreational puzzle, it has practical applications in various fields, including computer science, artificial intelligence, and operations research. It serves as a useful example for testing and evaluating search and optimization algorithms.

8. **Complexity:** The N-Queens problem can become computationally challenging as N increases. The problem's time complexity grows exponentially with N, making it suitable for benchmarking the performance of search and optimization algorithms.

9. **Extensions:** There are variations of the N-Queens problem, such as the N-Queens completion problem, where some queens are pre-placed, and the goal is to complete the board with additional queens.

Solving the N-Queens problem involves searching for valid queen placements on the chessboard while adhering to the constraints that no two queens threaten each other. Finding solutions can be achieved through various algorithms, and the problem remains a classic puzzle and a fascinating challenge in computer science and mathematics.

---------------------------------

Backtracking is a powerful algorithmic technique used to solve problems where we need to make a series of decisions, and each decision leads to a sequence of possibilities. It is especially useful for solving problems involving combinatorial search, such as finding all solutions, a single solution, or the best solution from a large search space. Backtracking explores these possibilities methodically and intelligently to arrive at a solution.

Here's a step-by-step explanation of how backtracking works:

1. **Decision Space:** Backtracking is typically used when you have a decision space or a set of choices at each step. You need to decide which choice to make, and these choices may lead to other decisions or actions.

2. **Exploration:** Start with the initial state and explore one choice at a time. This involves making a decision, moving to the next state, and recording the decision made.

3. **Recursion:** Backtracking often involves recursion, where you explore deeper into the decision space. As you make choices and move to the next state, you continue the process recursively.

4. **Constraints:** At each state, you check whether the current path or choice satisfies certain constraints. If the constraints are not met, you backtrack, undo the last decision, and explore another choice.

5. **Backtracking:** When you encounter a state where constraints are not satisfied, you backtrack to the previous state, undo the last decision, and explore an alternative choice. This process is called backtracking.

6. **Completion:** You continue exploring and backtracking until you find a solution that meets all constraints or until you've exhausted all possible choices in the decision space.

Backtracking is widely used to solve problems like the N-Queens problem, Sudoku puzzles, the traveling salesman problem, generating all permutations or combinations, and more. It's effective for problems where you need to systematically explore various combinations of choices to find a solution or optimize a solution.

Key characteristics of backtracking:

- It's a systematic and recursive approach.
- It's guided by constraints that determine whether a choice is valid.
- It explores decision space efficiently by discarding invalid choices early.
- It finds one or more solutions (or the best solution) from a search space.
- It may involve undoing decisions (backtracking) when constraints are violated.
- It's commonly implemented using recursion, and a stack or recursive call stack keeps track of decisions and states.

While backtracking can be a powerful tool for solving complex problems, it's important to optimize it by applying heuristics, pruning strategies, and other techniques to avoid exploring all possibilities in the decision space, especially when the search space is very large.
"""
